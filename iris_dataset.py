# -*- coding: utf-8 -*-
"""IRIS DATASET.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1acEtOjh9e9ug-lXPNm1cojIvBmJBQqw3

![imagen.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAYAAAA+s9J6AAAgAElEQVR4Xu2dCfRuU/nHj5UiSyR0RclQbouUmUIZb2UMZYgylpSp4qqQck0ZS5Shrq4UFVJoMA9Fyo0yNOgaiihKV1aRWv7/z14973p+++7xvOd9z3nf3z5r3cW97z577/Ps/d3P/Oz5nv//pypPoUChQGsUmK+AsDXal4ELBQwFCgjLRigUaJkCBYQtL0AZvlCggLDsgUKBlilQQNjyApThCwUKCMseKBRomQIFhC0vQBm+UKCAsOyBQoGWKVBA2PIClOELBQoIyx4oFGiZAgWELS9AGb5QoICw7IFCgZYpUEDY8gKU4QsFCgjLHigUaJkCBYQtL0AZvlCggLDsgUKBlilQQNjyApThCwUKCMseKBRomQIFhC0vQBm+UKCAsOyBQoGWKVBA2PIClOELBQoIyx4oFGiZAgWELS9AGb5QoICw7IFCgZYpUEDY8gKU4QsFCgjLHpiHAv/973+rF7zgBYUyQ6JAAeGQCD1qwxQgDm/FCgiHR+vkkQDAP/7xD9P+3//+d/Xss89OePdf//qX+fszzzxj/svviy66aLXSSislj+FryHjHH398dcEFF1RLLrlk9da3vrV605veVC233HLV6173OsMhC5fsm8wTOiggbJaejfT2q1/9qnrjG9+Y3ddrXvOa6pRTTqm22Wab7HflhZ/85CfVBhtsMM/7zOfWW2+tXvziF9fuu7zopkAB4ZB3xh//+Mfq5ptvrr7zne+Ykb/97W/PM4Pf/e531dSpU3v/rgH5y1/+svfvcKhlllmmuu+++yr971/+8pervffeu/KJlMxh5syZhtv9/ve/r175yldWG2+8seF4a621VvX617++euKJJ6p77723+ulPf1q99KUvrXbffXfz3/I0T4ECwuZpOqFHxLuf//zn1TXXXNPb9NLgW9/6VvXud787CEKAccstt/TafOUrX6n22Wcf8/ePf/zjRnTk+dGPflS9/e1v77X77W9/6xRPv/e971Xbbrtt9KsB/jve8Y5ql112qd7whjdE25cG9SlQQFifdsE34UJXXnll9bGPfcxwG3kAynrrrVdtscUW1dprr+3sQ3NCwHDnnXf22unf6OsHP/hB77fPf/7z1cEHH2z+/sUvfrHab7/9JvRvi7m8f8QRRxjdb+7cuYaj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)

---

UNIVERSIDAD AUTONOMA DE AGUASCALIENTES

CENTRO DE CIENCIAS BASICAS

DEPARTAMENTO DE CIENCIAS DE LA COMPUTACION

APRENDIZAJE INTELIGENTE


EMILIO LUNA PÉREZ

SEMESTRE ENERO-JUNIO DE 2023
"""

import numpy as np
import pandas as pd

#Importamos el dataset para iniciar el análisis
iris = pd.read_csv("iris.csv")

#Visualizamos los primeros 5 datos del dataset
print(iris.head())

#Análizamos los datos que tenemos disponibles
print('Información del dataset:')
print(iris.info())

print('Descripción del dataset:')
print(iris.describe())

print('Distribución de las especies de Iris:')
print(iris.groupby('variety').size())

import matplotlib.pyplot as plt

#Grafico Sepal - Longitud vs Ancho
fig = iris[iris.variety == 'Setosa'].plot(kind='scatter', x='sepal.length', y='sepal.width', color='blue', label='Setosa')
iris[iris.variety == 'Versicolor'].plot(kind='scatter', x='sepal.length', y='sepal.width', color='green', label='Versicolor', ax=fig)
iris[iris.variety == 'Virginica'].plot(kind='scatter', x='sepal.length', y='sepal.width', color='red', label='Virginica', ax=fig)

fig.set_xlabel('Sépalo - Longitud')
fig.set_ylabel('Sépalo - Ancho')
fig.set_title('Sépalo - Longitud vs Ancho')
plt.show()

#Grafico Pétalo - Longitud vs Ancho
fig = iris[iris.variety == 'Setosa'].plot(kind='scatter', x='petal.length', y='petal.width', color='blue', label='Setosa')
iris[iris.variety == 'Versicolor'].plot(kind='scatter', x='petal.length', y='petal.width', color='green', label='Versicolor', ax=fig)
iris[iris.variety == 'Virginica'].plot(kind='scatter', x='petal.length', y='petal.width', color='red', label='Virginica', ax=fig)

fig.set_xlabel('Pétalo - Longitud')
fig.set_ylabel('Pétalo - Ancho')
fig.set_title('Pétalo Longitud vs Ancho')
plt.show()

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier

#Separo todos los datos con las características y las etiquetas o resultados
X = np.array(iris.drop(['variety'], 1))
y = np.array(iris['variety'])

#Separo los datos de "train" en entrenamiento y prueba para probar los algoritmos
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

print('Son {} datos para entrenamiento y {} datos para prueba'.format(X_train.shape[0], X_test.shape[0]))

#Modelo de Regresión Logística
algoritmo = LogisticRegression()
algoritmo.fit(X_train, y_train)
Y_pred = algoritmo.predict(X_test)
print('Precisión Regresión Logística: {}'.format(algoritmo.score(X_train, y_train)))

#Modelo de Máquinas de Vectores de Soporte
algoritmo = SVC()
algoritmo.fit(X_train, y_train)
Y_pred = algoritmo.predict(X_test)
print('Precisión Máquinas de Vectores de Soporte: {}'.format(algoritmo.score(X_train, y_train)))

#Modelo de Vecinos más Cercanos
algoritmo = KNeighborsClassifier(n_neighbors=5)
algoritmo.fit(X_train, y_train)
Y_pred = algoritmo.predict(X_test)
print('Precisión Vecinos más Cercanos: {}'.format(algoritmo.score(X_train, y_train)))

#Modelo de Árboles de Decisión Clasificación
algoritmo = DecisionTreeClassifier()
algoritmo.fit(X_train, y_train)
Y_pred = algoritmo.predict(X_test)
print('Precisión Árboles de Decisión Clasificación: {}'.format(algoritmo.score(X_train, y_train)))

#Separo todos los datos con las características y las etiquetas o resultados
sepalo = iris[['sepal.length','sepal.width','variety']]

X_sepalo = np.array(sepalo.drop(['variety'], 1))
y_sepalo = np.array(sepalo['variety'])

#Separo los datos de "train" en entrenamiento y prueba para probar los algoritmos
X_train_s, X_test_s, y_train_s, y_test_s = train_test_split(X_sepalo, y_sepalo, test_size=0.2)

print('Son {} datos sépalo para entrenamiento y {} datos sépalo para prueba'.format(X_train.shape[0], X_test.shape[0]))

#Modelo de Regresión Logística
algoritmo = LogisticRegression()
algoritmo.fit(X_train_s, y_train_s)
Y_pred = algoritmo.predict(X_test_s)
print('Precisión Regresión Logística - Sépalo: {}'.format(algoritmo.score(X_train_s, y_train_s)))

#Modelo de Máquinas de Vectores de Soporte
algoritmo = SVC()
algoritmo.fit(X_train_s, y_train_s)
Y_pred = algoritmo.predict(X_test_s)
print('Precisión Máquinas de Vectores de Soporte - Sépalo: {}'.format(algoritmo.score(X_train_s, y_train_s)))

#Modelo de Vecinos más Cercanos
algoritmo = KNeighborsClassifier(n_neighbors=5)
algoritmo.fit(X_train_s, y_train_s)
Y_pred = algoritmo.predict(X_test_s)
print('Precisión Vecinos más Cercanos - Sépalo: {}'.format(algoritmo.score(X_train_s, y_train_s)))

#Modelo de Árboles de Decisión Clasificación
algoritmo = DecisionTreeClassifier()
algoritmo.fit(X_train_s, y_train_s)
Y_pred = algoritmo.predict(X_test_s)
print('Precisión Árboles de Decisión Clasificación - Sépalo: {}'.format(algoritmo.score(X_train_s, y_train_s)))

petalo = iris[['petal.length','petal.width','variety']]

X_petalo = np.array(petalo.drop(['variety'], 1))
y_petalo = np.array(petalo['variety'])

#Separo los datos de "train" en entrenamiento y prueba para probar los algoritmos
X_train_p, X_test_p, y_train_p, y_test_p = train_test_split(X_petalo, y_petalo, test_size=0.2)

print('Son {} datos pétalo para entrenamiento y {} datos pétalo para prueba'.format(X_train.shape[0], X_test.shape[0]))

#Modelo de Regresión Logística
algoritmo = LogisticRegression()
algoritmo.fit(X_train_p, y_train_p)
Y_pred = algoritmo.predict(X_test_p)
print('Precisión Regresión Logística - Pétalo: {}'.format(algoritmo.score(X_train_p, y_train_p)))

#Modelo de Máquinas de Vectores de Soporte
algoritmo = SVC()
algoritmo.fit(X_train_p, y_train_p)
Y_pred = algoritmo.predict(X_test_p)
print('Precisión Máquinas de Vectores de Soporte - Pétalo: {}'.format(algoritmo.score(X_train_p, y_train_p)))

#Modelo de Vecinos más Cercanos
algoritmo = KNeighborsClassifier(n_neighbors=5)
algoritmo.fit(X_train_p, y_train_p)
Y_pred = algoritmo.predict(X_test_p)
print('Precisión Vecinos más Cercanos - Pétalo: {}'.format(algoritmo.score(X_train_p, y_train_p)))

#Modelo de Árboles de Decisión Clasificación
algoritmo = DecisionTreeClassifier()
algoritmo.fit(X_train_p, y_train_p)
Y_pred = algoritmo.predict(X_test_p)
print('Precisión Árboles de Decisión Clasificación - Pétalo: {}'.format(algoritmo.score(X_train_p, y_train_p)))

"""USANDO EL ALGORITMO DEL PERCEPTRON"""

import numpy as np
import matplotlib.pyplot as plt

personas=np.array([[0.3,0.4],[0.4,0.3],
                   [0.3,0.2],[0.4,0.1],
                   [0.5,0.4],[0.4,0.8],
                   [0.6,0.8],[0.5,0.6],
                   [0.7,0.6],[0.8,0.5]])

clases=np.array([0,0,0,0,0,1,1,1,1,1])

def activacion (pesos,x,b):
  z=pesos*x
  if z.sum()+b>0:
    return 1
  else:
    return 0

pesos=np.random.uniform(-1,1,size=2)
b=np.random.uniform(-1,1)
pesos,b,activacion(pesos,[1,1],b)

pesos=np.random.uniform(-1,1,size=2)
b=np.random.uniform(-1,1)
taza_de_aprendizaje=0.01
epocas=100

for epoca in range(epocas):
  error_total=0
  for i in range(len(personas)):
    prediccion=activacion(pesos,personas[i],b)
    error=clases[i]-prediccion
    error_total+=error**2
    pesos[0]+=taza_de_aprendizaje*personas[i][0]*error
    pesos[1]+=taza_de_aprendizaje*personas[i][1]*error
    b+=taza_de_aprendizaje*error
  print(error_total,end=" ")

"""USANDO SCIKIT-LEARN 
 Multi-layer Perceptron

"""

#https://scikit-learn.org/stable/modules/neural_networks_supervised.html
 from sklearn.neural_network import MLPClassifier
X = [[0., 0.], [1., 1.]]
y = [0, 1]
clf = MLPClassifier(solver='lbfgs', alpha=1e-5,hidden_layer_sizes=(5, 2), random_state=1)
clf.fit(X, y)
MLPClassifier(alpha=1e-05, hidden_layer_sizes=(5, 2), random_state=1,solver='lbfgs')
clf.predict([[2., 2.], [-1., -2.]])

for coef in clf.coefs_:
  print(coef.shape )

clf.predict_proba([[2., 2.], [1., 2.]])

"""```
# Mutiples categorias
>>> X = [[0., 0.], [1., 1.]]
>>> y = [[0, 1], [1, 1]]
>>> clf = MLPClassifier(solver='lbfgs', alpha=1e-5,
...                     hidden_layer_sizes=(15,), random_state=1)
...
>>> clf.fit(X, y)
MLPClassifier(alpha=1e-05, hidden_layer_sizes=(15,), random_state=1,
              solver='lbfgs')
>>> clf.predict([[1., 2.]])
array([[1, 1]])
>>> clf.predict([[0., 0.]])
array([[0, 1]])
```

Mas del perceptron


```

https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Perceptron.html#sklearn.linear_model.Perceptron

>> from sklearn.datasets import load_digits
>>> from sklearn.linear_model import Perceptron
>>> X, y = load_digits(return_X_y=True)
>>> clf = Perceptron(tol=1e-3, random_state=0)
>>> clf.fit(X, y)
Perceptron()
>>> clf.score(X, y)


```

decision_function(X)
	

Predict confidence scores for samples.

densify()
	

Convert coefficient matrix to dense array format.

fit(X, y[, coef_init, intercept_init, ...])
	

Fit linear model with Stochastic Gradient Descent.

get_params([deep])
	

Get parameters for this estimator.

partial_fit(X, y[, classes, sample_weight])
	

Perform one epoch of stochastic gradient descent on given samples.

predict(X)
	

Predict class labels for samples in X.

score(X, y[, sample_weight])
	

Return the mean accuracy on the given test data and labels.

set_params(**params)
	

Set the parameters of this estimator.

sparsify()
	

Convert coefficient matrix to sparse format.

**OTROS**
"""

# perc_diabetes_sklearn.py

import pandas as pd
from sklearn.linear_model import Perceptron


diabetes = pd.read_csv('diabetes.csv').values

# Extract the feature columns and outcome response
# into appropriate variables
X = diabetes[:, 0:8]
y = diabetes[:, 8]

# Create and fit a perceptron model (with reproducible
    # random seed)
model = Perceptron(random_state=1)
model.fit(X, y)

# Output the (in sample) mean accuracy score
# of the classification
print("%0.3f" % model.score(X, y))

# perc_diabetes_tensorflow.py

import pandas as pd
from tensorflow.keras.layers import Dense
from tensorflow.keras.models import Sequential
from tensorflow.keras.activations import hard_sigmoid


if __name__ == "__main__":
    # Load the Pima diabetes dataset from CSV
    # and convert into a NumPy matrix suitable for
    # extraction into X, y format needed for TensorFlow
    diabetes = pd.read_csv('diabetes.csv').values

    # Extract the feature columns and outcome response
    # into appropriate variables
    X = diabetes[:, 0:8]
    y = diabetes[:, 8]

    # Create the 'Perceptron' using the Keras API
    model = Sequential()
    model.add(Dense(1, input_shape=(8,), activation=hard_sigmoid, kernel_initializer='glorot_uniform'))
    model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

    # Train the perceptron using stochastic gradient descent
    # with a validation split of 20%
    model.fit(X, y, epochs=225, batch_size=25, verbose=1, validation_split=0.2)

    # Evaluate the model accuracy
    _, accuracy = model.evaluate(X, y)
    print("%0.3f" % accuracy)